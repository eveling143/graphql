"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Merges all definitions of the given operation type.
 *
 * @param defs Type definitions to merge
 * @param type Operation type to merge
 */
function merge(defs, type) {
    var result;
    defs = defs.filter(function (def) {
        // filter out falsy values just incase
        if (!def)
            return false;
        // reset def.definitions to be the filtered version so the `type` that
        // was passed in doesn't exist in it anymore
        def.definitions = def.definitions.filter(function (definition) {
            var kind = definition.kind, name = definition.name, fields = definition.fields;
            if (kind === 'ObjectTypeDefinition' && name.kind === 'Name' && name.value === type) {
                if (!result) {
                    result = definition;
                }
                else {
                    result.fields = result.fields.concat(fields);
                }
                // remove the definition because it's been added to the result and
                // shouldn't exist here anymore
                return false;
            }
            return true;
        });
        if (def.definitions.length === 0) {
            return false; // operation was the only definition so this can be removed
        }
        return true;
    });
    // update to be `result?.fields?.length` when it's available
    if (((result || {}).fields || []).length) {
        if (result.fields.length > 1) {
            // filters out duplicate keys. The last key always wins
            result.fields = result.fields.filter(function (field, i, array) {
                return !array.slice(i + 1).find(function (obj) { return obj.name.value === field.name.value; });
            });
        }
        defs.push({
            kind: "Document",
            definitions: [result]
        });
    }
    return defs;
}
exports.merge = merge;
/**
 * Merges all query, mutation, and subscription type definitions.
 *
 * @param defs Type definitions to merge
 * @param types any additonal types you want to target
 */
function mergeTypeDefs(defs, types) {
    if (types === void 0) { types = []; }
    // handles strings and arrays of strings
    // also always includes these base 3
    types = ['Query', 'Mutation', 'Subscription'].concat(types);
    return types.reduce(function (prev, next) { return merge(prev, next); }, defs);
}
exports.mergeTypeDefs = mergeTypeDefs;
// export default as well so people can rename it to be what ever they want
exports.default = mergeTypeDefs;
//# sourceMappingURL=mergeTypeDefs.js.map